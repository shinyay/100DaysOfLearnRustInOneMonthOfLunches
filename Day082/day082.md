# Day 82

## Notes

### Regular threads and 'static guarantee

When you use regular threads (spawned using `std::thread::spawn`), you need to ensure that the data you're passing to the thread lives long enough to satisfy the `'static` lifetime requirement. This requirement is because threads can outlive the scope they were created in, and Rust's ownership system ensures that data is valid and accessible for the entire lifetime of the thread.

However, sometimes you want to pass non-`'static` data to a thread. In such cases, you have a couple of options:

1. **Using `Arc` (Atomic Reference Counting):** `Arc` allows you to share ownership of data across threads. It increases the reference count when cloned and decreases it when the reference goes out of scope. This allows you to ensure that the data lives as long as there are references to it.

2. **Using the `move` Keyword:** When you spawn a thread and pass data to it, you can use the `move` keyword to transfer ownership of the data to the thread. This means that the data will move into the thread's scope, and you no longer have access to it in the main thread. This approach is particularly useful when you have non-`'static` data that you want to use within the thread.

Here's an example to illustrate these concepts:

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data = vec![1, 2, 3, 4, 5];

    // Using Arc to share ownership with regular threads
    let shared_data = Arc::new(data.clone());
    let handle = thread::spawn(move || {
        // Inside the thread, you can access shared_data
        println!("Thread: {:?}", shared_data);
    });

    // Main thread still has ownership of data
    println!("Main thread: {:?}", data);

    // Wait for the thread to finish
    handle.join().unwrap();
}
```

In this example, we use `Arc` to share ownership of `data` with the thread spawned by `thread::spawn`. This ensures that the data outlives the thread and satisfies the `'static` requirement. Additionally, we use the `move` keyword to transfer ownership of `data` to the thread, which means the main thread no longer has access to it.

Remember that `Arc` is for shared ownership, and the `move` keyword is for transferring ownership to the thread. Choose the approach that fits your specific use case and the lifetime requirements of the data you're working with.

## Key Takeaways
