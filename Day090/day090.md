# Day 90

## Notes

**Box** is a smart pointer that's used for heap allocation. It allows you to store and manage data on the heap rather than the stack.

### Stack and Heap in Rust

1. **Stack**:
   - The stack is a region of memory that's used for storing data with a known, fixed size at compile time.
   - It operates in a last-in, first-out (LIFO) manner, similar to a stack of plates. When a function is called, a new stack frame is created, and when the function returns, that frame is removed.
   - Stack data is typically faster to access than heap data because of its predictable allocation and deallocation pattern.
   - Rust uses the stack for storing variables with a known, fixed size, such as integers, booleans, and function call frames.

2. **Heap**:
   - The heap is a region of memory used for storing data with a dynamic or unknown size at compile time. It allows for the allocation and deallocation of memory at runtime.
   - Heap data doesn't follow a strict LIFO pattern and can be allocated and deallocated in any order.
   - Accessing heap data is generally slower than stack data because it involves dereferencing pointers.
   - In Rust, the heap is used for dynamic data structures like `String`, `Vec`, and custom data types allocated with `Box`, `Rc`, or `Arc`.

#### Key Differences

- **Stack** data has a known, fixed size at compile time, while **heap** data has a dynamic or unknown size.
- **Stack** memory is automatically managed, with data being allocated and deallocated in a strict order as functions are called and return. **Heap** memory requires explicit allocation and deallocation.
- **Stack** access is faster due to its predictable nature, while **heap** access is slower due to the need to follow pointers.
- Rust's ownership system enforces strict rules for managing heap data to prevent issues like data races and memory leaks, making it safer than many other languages when dealing with heap-allocated memory.

### Box

`Box` is a smart pointer that provides heap allocation for values. It's a fundamental type in Rust's memory management, allowing you to allocate and manage data on the heap instead of the stack.

1. **Heap Allocation**:
   - Unlike stack-based variables, which have a fixed size known at compile time, heap allocation allows you to store data of dynamic or unknown size. `Box` provides a way to allocate data on the heap, where the size can vary.

```rust
fn main() {
    // Create a Box containing an integer allocated on the heap
    let my_boxed_integer: Box<i32> = Box::new(42);

    // Create a Box containing a String allocated on the heap
    let my_boxed_string: Box<String> = Box::new(String::from("Hello, Rust!"));

    // Access and print the values stored in the Boxes
    println!("Integer value: {}", *my_boxed_integer);
    println!("String value: {}", *my_boxed_string);
}
```

2. **Ownership**:
   - A `Box` has ownership of the data it points to. This means it's responsible for cleaning up the data when it goes out of scope. When a `Box` is dropped, it releases the memory it allocated on the heap.

```rust
fn main() {
    // Creating a Box containing an integer on the heap
    let my_boxed_integer: Box<i32> = Box::new(42);

    // Accessing the value through the Box
    let value = *my_boxed_integer;
    println!("Value inside the Box: {}", value);

    // After this point, my_boxed_integer goes out of scope and is deallocated.
    // Rust automatically frees the memory held by the Box.
    
    // Attempting to access my_boxed_integer would result in a compilation error,
    // because it's no longer valid.
    
    // Uncommenting the next line would result in a compilation error.
    // println!("Value inside the Box after deallocation: {}", *my_boxed_integer);
}
```

3. **Fixed Size**:
   - The size of a `Box` itself is fixed and known at compile time. It typically consists of a pointer to the heap-allocated data and some metadata for tracking the data's size and type.


## Key Takeaways
