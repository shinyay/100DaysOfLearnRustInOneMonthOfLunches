# Day 71

## Notes

### Closures as arguments

The following function signature shows that **it takes a closure**, **takes by value** (`FnOnce` = **takes by value**), and doesn't return anything. So now we can call this closure that takes nothing and write whatever we like inside it.

Take a look at the following function. My function defines like the following:

- `fn my_function_fnonce<F>(f: F) where F: FnOnce() { f(); }`
  - `(f: F)` shows that parameter is **Closure**
  - `F: FnOnce()` shows that the closure implements `FnOnce`

```rust
fn my_function_fnonce<F>(f: F)
where
    F: FnOnce(),
{
    f();
}

fn main() {
    let my_vec = vec![1, 2, 3, 4, 5];
    my_function_fnonce(|| {
        my_vec
            .into_iter()
            .for_each(|x| println!("Count: {x}"));
    });
}
```

- [Rust Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=4f55e4a5e483d4675aa8f6044155f082)

This clousure implements `FnOnce`, so it takes by value. Therefore you can't call it with `my_vec`.
If you want to take teke by reference, the closure shoudle be implementes with `Fn`

```rust
fn my_function_fn<F>(f: F)
where
    F: Fn(),
{
    f();
}

fn main() {
    let my_vec = vec![1, 2, 3, 4, 5];
    my_function_fn(|| {
        my_vec
            .iter()
            .for_each(|x| println!("Count: {x}"));
    });
    my_function_fn(|| {
        my_vec
            .iter()
            .for_each(|x| println!("Doubled: {}", x*2));
    });
}
```

Let us look again at examples of the use of the three types of closures:

```rust
fn my_function_fnonce<F: FnOnce()>(f: F) {
    print!("[my_function_fnonce]");
    f();
}

fn my_function_fnmut<F: FnMut()>(mut f: F) {
    print!("[my_function_fnmut]");
    f();
    print!("[my_function_fnmut]");
    f();
}

fn my_function_fn<F: Fn()>(f: F) {
    print!("[my_function_fn]");
    f();
    print!("[my_function_fn]");
    f();
}

fn main() {
    let mut my_string = "Hello Closure".to_string();
    
    let my_closure_fn = || {
        println!("{}", my_string);
    };
    my_closure_fn();
    my_function_fn(my_closure_fn);

    let mut my_closure_fnmut = || {
        my_string.push_str(" in Rust");
        println!("{}", my_string);
    };
    my_closure_fnmut();
    my_function_fnmut(my_closure_fnmut);

    let my_closure_drop = || {
        println!("Dropping: {}", my_string);
        drop(my_string);
    };
    // my_closure_drop();
    my_function_fnonce(my_closure_drop);
}
```

- [Rust Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=5e1fe112ab5c6ace69c555430670aa47)

### Trait for Fn, FnMut and FnOnce

- [std::ops::Fn](https://doc.rust-lang.org/std/ops/trait.Fn.html)

```rust
pub trait Fn<Args>: FnMut<Args>
```

This declaration means that a closure needs to implement `FnMut` before it can implement `Fn`.

## Key Takeaways
