# Day 46

## Notes

### Chaining methods

> With an imperative approach, a developer writes code that specifies the steps that the computer must take to accomplish the goal. This is sometimes referred to as algorithmic programming. In contrast, a functional approach involves composing the problem as a set of functions to be executed.

The following style is **Impleratice way**:

```rust
fn main() {
    let mut my_vec = Vec::new();
    let mut counter = 1;

    while counter < 10 {
        my_vec.push(counter);
        counter += 1;
    }

    println!("counter:{:?}", my_vec);
}
```

On the other hand, the next is **Functional way**:

```rust
fn main() {
    // let my_vec = (1..).take(10).collect::<Vec<i32>>();
    let my_vec: Vec<i32> = (1..).take(10).collect();
    println!("conter:{:?}", my_vec);
}
```

- [trait.Iterator#method.collect](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect)

### Iterators

An iterator is a construct that can give you the items in a collection, one at a time. 

- `.iter()` for an iterator of references
  - > `iter()`, which iterates over &T.
- `.iter_mut()` for an iterator of mutable references
  - > `iter_mut()`, which iterates over &mut T.
- `.into_iter()` for an iterator of values (not references)
  - > `into_iter()`, which iterates over T.

## Key Takeaways
