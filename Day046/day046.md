# Day 46

## Notes

### Chaining methods

> With an imperative approach, a developer writes code that specifies the steps that the computer must take to accomplish the goal. This is sometimes referred to as algorithmic programming. In contrast, a functional approach involves composing the problem as a set of functions to be executed.

The following style is **Impleratice way**:

```rust
fn main() {
    let mut my_vec = Vec::new();
    let mut counter = 1;

    while counter < 10 {
        my_vec.push(counter);
        counter += 1;
    }

    println!("counter:{:?}", my_vec);
}
```

On the other hand, the next is **Functional way**:

```rust
fn main() {
    // let my_vec = (1..).take(10).collect::<Vec<i32>>();
    let my_vec: Vec<i32> = (1..).take(10).collect();
    println!("conter:{:?}", my_vec);
}
```

- [trait.Iterator#method.collect](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect)

### Iterators

An iterator is a construct that can give you the items in a collection, one at a time. 

- `.iter()` for an iterator of references
  - > `iter()`, which iterates over &T.
- `.iter_mut()` for an iterator of mutable references
  - > `iter_mut()`, which iterates over &mut T.
- `.into_iter()` for an iterator of values (not references)
  - > `into_iter()`, which iterates over T.

> so typing for item in iterator is the same as typing for item in iterator.into_iter().

```rust
fn main() {
    let my_vec = vec![1, 2, 3, 4, 5];
    let mut my_mut_vec = vec![10, 20, 30, 40, 50];

    for item in my_vec.iter() {
        println!("&i32: {}", item);
    }

    for item in my_vec.into_iter() {
        println!("i32: {}", item);
    }

    // for item in my_vec {
    //     println!("i32: {}", item);
    // }

    for item in my_mut_vec.iter_mut() {
        *item *= 10;
        println!("&i32: {}", item);
    }
    println!("my_mut_vec: {:?}", my_mut_vec);
}
```

Now 

## Key Takeaways

- `.iter()` for an iterator of references
  - > `iter()`, which iterates over &T.
- `.iter_mut()` for an iterator of mutable references
  - > `iter_mut()`, which iterates over &mut T.
- `.into_iter()` for an iterator of values (not references)
  - > `into_iter()`, which iterates over T.