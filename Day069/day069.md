# Day 69

## Notes

Rust, like most programming languages, uses threads provided by the operating system for concurrency
Rust is unique in that it provides features related to thread creation, synchronization, and concurrency management, while having a strict type system related to thread-safety and race condition avoidance.

### Multiple threads

An OS thread is created using the `std::thread` module; a new thread is created by calling the `std::thread::spawn()` function, and the specified closure (function) is executed within that thread.

- [std::thread::spawn](https://doc.rust-lang.org/std/thread/fn.spawn.html)
  - Spawns a new thread, returning a `JoinHandle` for it.

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T + Send + 'static,
    T: Send + 'static,
```

Run the follwing sample. The result changes each time it is executed. That is because `main()` finished before the thread finishes.

```rust
fn main() {
    for count in 1..10 {
        std::thread::spawn(move || {
            println!("[{count}] Hello, world!");
        });
    }
}
```

The `std::thread::spawn` function returs `JoinHandle`, which is an owned permission to join on a thread.

```rust
fn main() {
    for count in 1..10 {
        let my_hundle = std::thread::spawn(move || {
            println!("[{}] Hello, thread!", count)
        });

        my_hundle.join();
    }
}
```

```shell
[1] Hello, thread!
[2] Hello, thread!
[3] Hello, thread!
[4] Hello, thread!
[5] Hello, thread!
[6] Hello, thread!
[7] Hello, thread!
[8] Hello, thread!
[9] Hello, thread!
```

Let's take a look at `join` function:

- [pub fn join(self) -> Result<T>](https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join)
  - Waits for the associated thread to finish. This function will return immediately if the associated thread has already finished.

So I just added `my_hundle.join();`, which means "wait until all the threads are done".

By the way, there is one keyword you may not be familiar with. It is `move`. Let's see what happens when you run without this `move`.

```rust
fn main() {
    for count in 1..10 {
        let my_hundle = std::thread::spawn(|| {
            println!("[{}] Hello, thread!", count)
        });

        my_hundle.join();
    }
}
```

```shell
error[E0373]: closure may outlive the current function, but it borrows `count`, which is owned by the current function
 --> src/main.rs:3:44
  |
3 |         let my_hundle = std::thread::spawn(|| {
  |                                            ^^ may outlive borrowed value `count`
4 |             println!("[{}] Hello, thread!", count)
  |                                             ----- `count` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --> src/main.rs:3:25
  |
3 |           let my_hundle = std::thread::spawn(|| {
  |  _________________________^
4 | |             println!("[{}] Hello, thread!", count)
5 | |         });
  | |__________^
help: to force the closure to take ownership of `count` (and any other referenced variables), use the `move` keyword
  |
3 |         let my_hundle = std::thread::spawn(move || {
  |
```

Closures capture variables outside of functions, but by default they are captured by reference when they are captured.
The `move || {}` syntax allows this to be captured by ownership.

## Key Takeaways
