# Day 61

## Notes

`Cell`, which was **Interioe Mutability** I checked on Day 60.

The main purpose of `Cell` is to wrap a value of a Copy type and provide methods to read and write the value while avoiding Rust's usual borrowing rules.

`RefCell` is another way to change values without needing to declare `mut`.

### Interior mutability - RefCell

A mutable memory location with dynamically checked borrow rules.

- [`std::cell::RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html)
  - [`pub fn borrow(&self) -> Ref<'_, T>`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow)
    - Same as `&`
    - **Immutably borrows** the wrapped value.
    - The borrow lasts until the returned `Ref` exits scope. Multiple immutable borrows can be taken out at the same 
  - [`pub fn borrow_mut(&self) -> RefMut<'_, T>`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow_mut)
    - Same as `&mut`
    - **Mutably borrows** the wrapped value.
    - The borrow lasts until the returned `RefMut` or all RefMuts derived from it exit scope. The value cannot be borrowed while this borrow is active.
time.
  - [`pub fn replace(&self, t: T) -> T`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace)
    - Replaces the wrapped value with a new one, returning the old value, without deinitializing either one.
  - [`pub fn replace_with<F>(&self, f: F) -> T`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace_with)
    - Replaces the wrapped value with a new one computed from `f`, returning the old value, without deinitializing either one.

```rust
use std::{cell::RefCell, fmt::{Display, Formatter, Result}};

// #[derive(Debug)]
// struct Book {
//     author: String,
//     title: String,
//     category: String,
//     price: u32,
//     sale: bool,
// }

#[derive(Debug)]
struct Book {
    author: String,
    title: String,
    category: String,
    price: u32,
    sale: RefCell<bool>,
}

impl Book {
    
}

impl Display for Book {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        write!(f, "Title: {} | Price: {}", self.title, self.price)
    }
}

fn main() {
    let my_book = Book {
        author: "Shinya Yanagihara".to_string(),
        title: "Rust for Beginners".to_string(),
        category: "Rust".to_string(),
        price: 980,
        sale: RefCell::new(false),
    };
    println!("{:?}", my_book);

    my_book.sale.replace(true);
    println!("{:?}", my_book);

    let publication_date = 2010;
    my_book.sale.replace_with(|_| if publication_date < 2010 { true } else { false });
    println!("{:?}", my_book);

}
```

## Key Takeaways
