# Day 61

## Notes

`Cell`, which was **Interioe Mutability** I checked on Day 60.

The main purpose of `Cell` is to wrap a value of a Copy type and provide methods to read and write the value while avoiding Rust's usual borrowing rules.

`RefCell` is another way to change values without needing to declare `mut`.

### Interior mutability - RefCell

A mutable memory location with dynamically checked borrow rules.

- [`std::cell::RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html)
  - [`pub fn borrow(&self) -> Ref<'_, T>`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow)
    - Same as `&`
    - **Immutably borrows** the wrapped value.
    - The borrow lasts until the returned `Ref` exits scope. Multiple immutable borrows can be taken out at the same 
  - [`pub fn borrow_mut(&self) -> RefMut<'_, T>`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow_mut)
    - Same as `&mut`
    - **Mutably borrows** the wrapped value.
    - The borrow lasts until the returned `RefMut` or all RefMuts derived from it exit scope. The value cannot be borrowed while this borrow is active.
time.
  - [`pub fn replace(&self, t: T) -> T`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace)
    - Replaces the wrapped value with a new one, returning the old value, without deinitializing either one.
  - [`pub fn replace_with<F>(&self, f: F) -> T`](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace_with)
    - Replaces the wrapped value with a new one computed from `f`, returning the old value, without deinitializing either one.
## Key Takeaways
