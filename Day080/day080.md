# Day 80

## Notes

### Mutex

`Mutex` (short for mutual exclusion) is a synchronization primitive that helps manage access to shared data in a concurrent or multi-threaded environment. It prevents multiple threads from accessing the same data simultaneously, which can lead to data races and unpredictable behavior.

**Mutex in Rust:**

A `Mutex` ensures that only one thread can access the protected data at a time. When a thread wants to access the data, it "locks" the mutex, gaining exclusive access. Other threads attempting to access the data while the mutex is locked will be blocked until the mutex is released.

**Usage:**

`Mutex` is used in situations where you have shared data that needs to be safely accessed by multiple threads. This could include scenarios where you have a data structure or resource that multiple threads need to read from or write to. Without proper synchronization, simultaneous access from multiple threads can lead to data corruption, crashes, or other unexpected behavior.

**Key Concepts:**

- **Locking and Unlocking:** To access the protected data, a thread must first lock the mutex. Once the thread is done using the data, it should unlock the mutex to allow other threads to access it.

- **Deadlocks:** Be careful with locking and unlocking. If one thread forgets to unlock the mutex, it can lead to a deadlock, where other threads are stuck waiting forever.

**Example:**

Here's a simple example of using a `Mutex` in Rust:

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = counter.clone();
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final count: {}", *counter.lock().unwrap());
}
```

In this example, we use a `Mutex` to safely update a counter from multiple threads. Each thread locks the mutex, updates the counter, and then releases the mutex. This ensures that only one thread can modify the counter at a time, avoiding data races.



## Key Takeaways
