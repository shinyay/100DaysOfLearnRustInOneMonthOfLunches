# Day 67

## Notes

- [std::borrow::Cow](https://doc.rust-lang.org/std/borrow/enum.Cow.html)

The type `Cow` is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the `Borrow` trait.

### Cow

Imagine you have a collection of data, like a string or a vector, and you want to pass it around your code. But sometimes you want to just read the data, and other times you might want to modify it. In Rust, the `Cow` type (short for "clone on write") helps you do this in an efficient way.

Here's a simple explanation:

- **Read without Owning**: When you want to read the data without changing it, you can borrow a reference to it. This is fast and doesn't need any copying.

- **Modify with Cloning**: But if you want to change the data, you usually need to own it. This means making a copy of it, which can be slow and use a lot of memory if the data is big.

- **Clone on Write with Cow**: The `Cow` type lets you do both. When you need to read, you get a reference to the data. But if you want to change it, `Cow` will automatically make a copy for you. This way, you only make a copy when you really need to change the data, which can save time and memory.

In code, it might look like this:

```rust
use std::borrow::Cow;

fn process_data(data: Cow<str>) {
    let modified_data = if data.len() > 10 {
        data.to_uppercase()
    } else {
        data.to_string()
    };
    
    println!("Processed data: {}", modified_data);
}

fn main() {
    let data = "Hello!".to_string();
    process_data(Cow::Borrowed(&data));  // Reading without owning
    
    let data = "Hello, Rust!!".to_string();
    process_data(Cow::Owned(data));  // Making a copy only if needed
}
```

- [Rust Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b94dca29c334ad5736b3ed0793a70c91)

In this example, the `Cow` type helps you avoid unnecessary copying. When the data is short, it borrows the reference (`Cow::Borrowed`). When the data is long and needs modification, it makes a copy (`Cow::Owned`) before changing it.

So, with `Cow`, you get the best of both worlds: efficient reading and memory-saving copying when needed.

## Key Takeaways
