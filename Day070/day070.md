# Day 70

## Notes

### Types of closures

In Rust, closures are a convenient way to define anonymous functions that can capture variables from their surrounding environment. Closures are flexible and come in three different flavors or traits: `Fn`, `FnMut`, and `FnOnce`. These traits determine how the closure can capture and manipulate variables.

1. **`Fn` Closures**:
   Closures that implement the `Fn` trait can only capture variables by reference. They can't modify the captured variables. They are used when you only need to read the captured variables within the closure.

2. **`FnMut` Closures**:
   Closures that implement the `FnMut` trait can capture variables by mutable reference. They can modify the captured variables. They are used when you need to modify the captured variables within the closure.

3. **`FnOnce` Closures**:
   Closures that implement the `FnOnce` trait can capture variables by value. They take ownership of the captured variables and can consume them. They are used when you need to move the captured variables into the closure.

Here's a quick example to illustrate the differences:

```rust
fn main() {
    let x = 42;
    
    // Fn closure (read-only)
    let fn_closure = || {
        println!("Fn closure: x = {}", x);
    };
    
    // FnMut closure (can modify)
    let mut fn_mut_closure = || {
        println!("FnMut closure: x = {}", x);
    };
    
    // FnOnce closure (consumes)
    let fn_once_closure = || {
        println!("FnOnce closure: x = {}", x);
    };
    
    fn_closure();
    fn_mut_closure();
    fn_once_closure();
    
    // Uncommenting the following line would result in a compilation error
    // println!("x after closures: {}", x);
}
```

In this example, the `Fn` closure `fn_closure` captures `x` by reference and only reads it. The `FnMut` closure `fn_mut_closure` captures `x` by mutable reference, allowing it to modify `x`. The `FnOnce` closure `fn_once_closure` captures `x` by value, consuming it.

Remember that closures are versatile tools in Rust, allowing you to encapsulate functionality with different levels of access to captured variables. The choice of which trait to use depends on whether you only need to read, need to modify, or want to consume the captured variables.

## Key Takeaways
